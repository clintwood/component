#!/usr/bin/env node

/**
 * Module dependencies.
 */

var program = require('commander')
  , component = require('..')
  , utils = component.utils
  , log = utils.log
  , error = utils.error
  , url = require('url')
  , fs = require('fs')
  , exists = fs.existsSync
  , utils = component.utils
  , path = require('path')
  , resolve = path.resolve
  , rimraf = require('rimraf')
  ;

// options

program
  .usage('[options] <component_directory>')
  .option('-s, --skip', 'skip if the component is already installed')
  .option('-n, --nodeps', 'don\'t resolve dependents for this component')
  .option('-a, --all', 'symlink all components directory or matching search path(s)');

// examples

program.on('--help', function(){
  console.log('  Examples:');
  console.log();
  console.log('    # symlink a single component');
  console.log('    $ component link ../repo/tip');
  console.log();
  console.log('    # symlink multiple components');
  console.log('    $ component link ../repo/tip ../component/popover');
  console.log();
  console.log('    # symlink component only if it doesn\'t exist.');
  console.log('    $ component link -s ../component/popover');
  console.log();
  console.log('    # symlink component without installing dependents');
  console.log('    $ component link -n ../component/popover');
  console.log();
  console.log('    # symlink all components directory or matching search path(s)');
  console.log('    $ component link -a ../repos ../dev-repo/com*');
  console.log();
});

// parse argv

program.parse(process.argv);

// locals

var links = [];
var args = program.args;
var comps = './components';
var skipifexists = program.skip;
var nodeps = program.nodeps;
var all = program.all;

if (args.length == 0) program.help();

// repopulate args for --all option

if(all) {
  var dirs = [];
  args.forEach(function(arg) {
    var dir, regexp;
    // possible wildcard
    if(!exists(arg)) {
      dir = path.dirname(arg);
      if(!exists(dir)) utils.fatal('Path \'' + arg + '\' does not exist.');
      // escape common regex characters & create regexp filter
      regexp = path.basename(arg).replace(/(\^|\$|\(|\)|\<|\>|\[|\]|\{|\}|\.|\+|\?)/g, '\\$1');
      regexp = '^' + regexp.replace(/\*/g, '.*') + '$'; 
    } else {
      dir = arg;
    }
    // ls + filter
    fs.readdirSync(dir).forEach(function(file) {
      if(!regexp || (regexp && file.match(new RegExp(regexp)))) {
        var target = path.join(dir, file);
        if(fs.statSync(target).isDirectory() && dirs.indexOf(target) < 0)
          dirs.push(target);
      }
    });
  });
  args = dirs;
}

// build link info

args.forEach(function(arg) {
  var target = arg;
  if (!exists(target)) utils.fatal('Target path \'' + target + '\' does not exist.');
  
  // load targets component.json
  var conf = loadConfig(target);
  if(conf) {
    conf = ensureConf(conf, target);
    // link
    var link = {
      target: target,
      link: path.join(comps, repoDir(conf.repo)), 
      conf: conf
    }
    // add to list
    links.push(link);
  } else {
    log('ignoring', 'Target path \'' + target + '\' missing \'component.json\', not a component.');
  }
});

// ensure ./components exists

if(!exists(comps)) {
    fs.mkdirSync(comps);
}

// symlink each target

links.forEach(function (link) {
  if (exists(link.link)) {
    if (!skipifexists) {
      // rm -rf on existing link dir
      rimraf(link.link, function (err) {
        if (err) utils.fatal('Unable to replace link path \'' + link.link + '\'.');
        log('unlink', link.link);
        createSymlink(link);
      });
    } else {
      if (!nodeps) {
        installDependencies(link.conf);
      }
    }
  } else {
      createSymlink(link);
  }
});

// actually create the symlink and install dependencies

function createSymlink(link) {
  // note: sadly symlink appears to work differently on windows / linux, hence the fixup
  var linkTarget = ((process.platform !== "win32") ? path.join('../', link.target) : link.target);
  fs.symlink(linkTarget, link.link, 'junction', function (err) {
    if (err) utils.fatal(err);
    log('linked', link.link + ' -> ' + linkTarget);
    if (!nodeps) {
      installDependencies(link.conf);
    }
  });
}

// install dependencies given a component.json

function installDependencies(conf) {
  var deps = conf.dependencies;
  // install each dependent
  Object.keys(deps).forEach(function (dep) {
    var version = deps[dep];
    version = (version == '*') ? 'master' : version;
    if (!exists(path.join(comps, repoDir(dep)))) {
      install(conf, dep, version);
    }
  });
}

// helpers

// convert repo to component directory name
function repoDir(repo) {
  return repo.replace('/', '-');
}

// load component.json at from
function loadConfig(from) {
  var confPath = resolve(path.join(from, 'component.json'));
  if (exists(confPath)) {
    return require(confPath);
  } 
  // not found
  return null;
}

// ensure/default remotes, dependencies, etc
function ensureConf(conf, target) {
  conf = conf || {};
  conf.remotes = conf.remotes || [];
  conf.remotes.push('https://raw.github.com');
  conf.dependencies = conf.dependencies || [];
  // use the target directory name as the repo if it doesn't exist
  conf.repo = conf.repo || target.split(/[\/|\\]/).slice(-1)[0];
  return conf;
}

// TODO: The following is a copy paste (barring a 'conf' parameter change in install) from component-install... 
// @TJ you may want to refactor here...

// reporter

function report(pkg, options) {
  options = options || {};
  log('install', pkg.name + '@' + pkg.version);

  pkg.on('error', function(err){
    if (404 != err.status) utils.fatal(err.stack);

    if (options.error) {
      error(err.message);
      process.exit(1);
    }
  });

  pkg.on('dep', function(dep){
    log('dep', dep.name + '@' + dep.version);
    report(dep, options);
  });

  pkg.on('exists', function(dep){
    log('exists', dep.name + '@' + dep.version);
  });

  pkg.on('file', function(file){
    log('fetch', pkg.name + ':' + file);
  });

  pkg.on('end', function(){
    log('complete', pkg.name);
  });
}

// padding

process.on('exit', function(){
  console.log();
});

/**
 * Install package `name` at the given `version`
 * from all specified remotes.
 *
 * @param {String} name
 * @param {String} version
 * @api private
 */

function install(conf, name, version) {
  var i = 0;

  next();

  function next() {
    var remote = conf.remotes[i++];
    if (!remote) return;

    // parse remote
    var last = i == conf.remotes.length - 1;
    remote = url.parse(remote);

    // strip trailing /
    remote.href = remote.href.slice(0, -1);

    // kick of installation
    var pkg = component.install(name, version, {
      dest: program.out,
      force: program.force,
      dev: program.dev,
      remote: remote.href
    });

    // only error on the last remote otherwise
    // we assume it may be fetchable
    pkg.once('error', next);
    report(pkg, { error: !last });

    // TODO: add callback
    pkg.install();
  }
}
